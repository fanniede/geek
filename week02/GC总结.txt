串行 / 并行 /CMS/G1

串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除-
整理）算法。
两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。
因此这种 GC 算法不能充分利用多核 CPU。不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心。
CPU 利用率高，暂停时间长。

并行 GC（Parallel GC）
年轻代和老年代的垃圾回收都会触发 STW 事件。
在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweepcompact）算法。
并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到
更高的吞吐量。
在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；
在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。

CMS GC
其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-sweep (
标记-清除)算法。
CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
2. 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。
也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU 时。 默认情况下，
CMS 使用的并发线程数等于 CPU 核心数的 1/4。
如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智
的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。

G1 GC
全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最
多就优先清理它。
G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成
可预期且可配置的。
堆不再分成年轻代和老年代，而是划分为多个（通常是
2048个）可以存放对象的小块堆区域(smaller heap regions)。
每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor
区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来
就是年轻代，所有的 Old 区拼在一起那就是老年代。
这样划分之后，使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每
次只处理一部分内存块，称为此次 GC 的回收集(collection set)。每次 GC 暂停都会收集所
有年轻代的内存块，但一般只包含部分老年代的内存块。
G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是： 垃
圾最多的小块会被优先收集。这也是 G1 名称的由来。

选择正确的 GC 算法，唯一可行的方式就是去尝试，一般性的指导原则：
1. 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
2. 如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；
3. 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。
对于内存大小的考量：
1. 一般 4G 以上，算是比较大，用 G1 的性价比较高。
2. 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。

1. 串行 GC（Serial GC）: 单线程执行，应用需要暂停；
2. 并行 GC（ParNew、Parallel Scavenge、Parallel Old）: 多线程并行地执行垃圾回收，
关注于高吞吐；
3. CMS（Concurrent Mark-Sweep）: 多线程并发标记和清除，关注于降低延迟；
4. G1（G First）: 通过划分多个内存区域做增量整理和回收，进一步降低延迟；

目前绝大部分 Java 应用系统，堆内存并不大比如 2G-4G 以内，而且对 10ms 这种低延迟的 GC 暂停不敏感，也就是说处
理一个业务步骤，大概几百毫秒都是可以接受的，GC 暂停 100ms 还是 10ms 没多大区别。另一方面，系统的吞吐量反而
往往是我们追求的重点，这时候就需要考虑采用并行 GC。
如果堆内存再大一些，可以考虑 G1 GC。如果内存非常大（比如超过 16G，甚至是 64G、128G），或者是对延迟非常敏感
（比如高频量化交易系统），就需要考虑新 GC（ZGC/Shenandoah）。
